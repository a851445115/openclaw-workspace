#!/usr/bin/env python3
import argparse
import hashlib
import json
import os
import re
import subprocess
import sys
import time
from typing import Any, Dict, Optional, Sequence, Tuple

DEFAULT_GROUP_ID = "oc_041146c92a9ccb403a7f4f48fb59701d"
DEFAULT_ACCOUNT_ID = "orchestrator"

BOT_ROLES = {"orchestrator", "coder", "debugger", "invest-analyst", "broadcaster"}
MILESTONE_PREFIXES = ("[TASK]", "[CLAIM]", "[DONE]", "[BLOCKED]", "[DIAG]", "[REVIEW]")
BOT_OPENID_CONFIG_CANDIDATES = (
    os.path.join("config", "feishu-bot-openids.json"),
    os.path.join("state", "feishu-bot-openids.json"),
)
CALLBACK_DEDUP_STATE_FILE = os.path.join("state", "feishu-card-callback-dedup.json")
CALLBACK_DEDUP_MAX_ENTRIES = 2000
CALLBACK_DEDUP_DEFAULT_TTL_SEC = 86400
CALLBACK_DEDUP_FALLBACK_TTL_SEC = 300
CALLBACK_METADATA_HEADERS = (
    "Card callback (untrusted metadata):",
    "Card Callback (untrusted metadata):",
)


def extract_json_block(raw: str, header: str) -> Dict[str, Any]:
    m = re.search(re.escape(header) + r"\s*```json\s*(\{.*?\})\s*```", raw, flags=re.DOTALL)
    if not m:
        return {}
    try:
        obj = json.loads(m.group(1))
        return obj if isinstance(obj, dict) else {}
    except Exception:
        return {}


def normalize_message_text(raw: str) -> str:
    # Extract the message body from an OpenClaw Feishu wrapper text.
    # Keep multi-line messages intact by cutting off before metadata blocks.
    delim = raw.find("Conversation info (untrusted metadata):")
    head = raw if delim < 0 else raw[:delim]

    m = re.search(r"message in group\s+[^:]+:\s*", head, flags=re.IGNORECASE)
    if m:
        return head[m.end() :].strip()

    lines = [ln.strip() for ln in raw.splitlines() if ln.strip()]
    if lines:
        return lines[-1]
    return ""


def extract_callback_block(raw: str) -> Dict[str, Any]:
    for header in CALLBACK_METADATA_HEADERS:
        obj = extract_json_block(raw, header)
        if obj:
            return obj
    return {}


def deep_get(obj: Dict[str, Any], path: Sequence[str]) -> Any:
    cur: Any = obj
    for key in path:
        if not isinstance(cur, dict):
            return None
        cur = cur.get(key)
    return cur


def first_string(objects: Sequence[Dict[str, Any]], paths: Sequence[Sequence[str]]) -> str:
    for obj in objects:
        if not isinstance(obj, dict):
            continue
        for path in paths:
            v = deep_get(obj, path)
            if isinstance(v, (str, int, float)):
                s = str(v).strip()
                if s:
                    return s
    return ""


def build_callback_context(raw: str, conv: Dict[str, Any], sender: Dict[str, Any], actor_raw: str) -> Dict[str, Any]:
    callback = extract_callback_block(raw)
    if not callback:
        return {}

    command = first_string(
        [callback],
        [
            ("action", "value", "command"),
            ("event", "action", "value", "command"),
            ("action", "value", "cmd"),
            ("event", "action", "value", "cmd"),
            ("value", "command"),
            ("value", "cmd"),
            ("form_value", "command"),
            ("action", "form_value", "command"),
        ],
    )
    if not command:
        return {}

    message_id = first_string(
        [callback],
        [
            ("action", "value", "message_id"),
            ("action", "value", "messageId"),
            ("event", "action", "value", "message_id"),
            ("event", "action", "value", "messageId"),
            ("action", "value", "open_message_id"),
            ("action", "value", "openMessageId"),
            ("event", "action", "value", "open_message_id"),
            ("event", "action", "value", "openMessageId"),
        ],
    )
    if not message_id:
        message_id = first_string(
            [callback],
            [
                ("event", "message", "message_id"),
                ("event", "message", "open_message_id"),
                ("message", "message_id"),
                ("message", "open_message_id"),
                ("open_message_id",),
                ("message_id",),
                ("openMessageId",),
                ("messageId",),
            ],
        )
    if not message_id:
        message_id = first_string([conv], [("message_id",), ("open_message_id",), ("messageId",), ("openMessageId",)])

    action_ts = first_string(
        [callback],
        [
            ("action", "value", "action_ts"),
            ("action", "value", "actionTs"),
            ("event", "action", "value", "action_ts"),
            ("event", "action", "value", "actionTs"),
            ("action", "action_ts"),
            ("event", "action_ts"),
            ("action", "ts"),
            ("event", "ts"),
            ("action_ts",),
            ("actionTs",),
            ("ts",),
        ],
    )
    if not action_ts:
        action_ts = first_string([conv], [("action_ts",), ("actionTs",), ("ts",)])

    sender_key = first_string(
        [callback],
        [
            ("action", "value", "open_id"),
            ("action", "value", "openId"),
            ("action", "value", "user_id"),
            ("action", "value", "userId"),
            ("event", "action", "value", "open_id"),
            ("event", "action", "value", "openId"),
            ("event", "action", "value", "user_id"),
            ("event", "action", "value", "userId"),
            ("event", "operator", "operator_id", "open_id"),
            ("event", "operator", "operator_id", "user_id"),
            ("event", "operator", "open_id"),
            ("event", "operator", "user_id"),
            ("operator", "operator_id", "open_id"),
            ("operator", "operator_id", "user_id"),
            ("operator", "open_id"),
            ("operator", "user_id"),
            ("open_id",),
            ("user_id",),
            ("openId",),
            ("userId",),
        ],
    )
    if not sender_key:
        sender_key = first_string(
            [sender, conv],
            [
                ("open_id",),
                ("openId",),
                ("user_id",),
                ("userId",),
                ("sender_id",),
                ("sender",),
                ("name",),
                ("label",),
            ],
        )
    if not sender_key:
        sender_key = (actor_raw or "").strip() or "unknown"

    envelope_key = first_string(
        [callback],
        [
            ("event_id",),
            ("eventId",),
            ("event", "event_id"),
            ("event", "eventId"),
            ("event", "header", "event_id"),
            ("event", "header", "eventId"),
            ("header", "event_id"),
            ("header", "eventId"),
            ("token",),
            ("event", "token"),
            ("header", "token"),
        ],
    )

    command_norm = re.sub(r"\s+", " ", command).strip()
    dedup_mode = "stable_key"
    dedup_ttl_sec = CALLBACK_DEDUP_DEFAULT_TTL_SEC
    if message_id.strip() or action_ts.strip():
        dedup_basis = "|".join(
            [
                message_id.strip(),
                action_ts.strip(),
                sender_key.strip(),
                command_norm.lower(),
            ]
        )
    else:
        dedup_mode = "fallback_ttl"
        dedup_ttl_sec = CALLBACK_DEDUP_FALLBACK_TTL_SEC
        bucket = int(time.time() // CALLBACK_DEDUP_FALLBACK_TTL_SEC)
        dedup_basis = "|".join(
            [
                envelope_key.strip() or "no-envelope",
                sender_key.strip() or "no-sender",
                command_norm.lower(),
                str(bucket),
            ]
        )
    dedup_key = hashlib.sha1(dedup_basis.encode("utf-8")).hexdigest()

    return {
        "source": "card_callback",
        "command": command_norm,
        "messageId": message_id.strip(),
        "actionTs": action_ts.strip(),
        "senderKey": sender_key.strip(),
        "dedupMode": dedup_mode,
        "dedupTtlSec": dedup_ttl_sec,
        "eventEnvelopeKey": envelope_key.strip(),
        "dedupKey": dedup_key,
    }


def load_callback_dedup_state(root: str) -> Dict[str, Any]:
    path = os.path.join(root, CALLBACK_DEDUP_STATE_FILE)
    if not os.path.exists(path):
        return {"entries": {}}
    try:
        with open(path, "r", encoding="utf-8") as f:
            obj = json.load(f)
    except Exception:
        return {"entries": {}}
    if not isinstance(obj, dict):
        return {"entries": {}}
    entries = obj.get("entries")
    if not isinstance(entries, dict):
        obj["entries"] = {}
    return obj


def save_callback_dedup_state(root: str, state: Dict[str, Any]) -> None:
    path = os.path.join(root, CALLBACK_DEDUP_STATE_FILE)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=True, indent=2)
        f.write("\n")
    os.replace(tmp, path)


def remember_callback_once(root: str, dedup_key: str, context: Dict[str, Any], ttl_sec: int) -> bool:
    if not dedup_key:
        return False

    now = int(time.time())
    ttl = ttl_sec if isinstance(ttl_sec, int) and ttl_sec > 0 else CALLBACK_DEDUP_DEFAULT_TTL_SEC
    state = load_callback_dedup_state(root)
    raw_entries = state.setdefault("entries", {})
    if not isinstance(raw_entries, dict):
        raw_entries = {}
    entries: Dict[str, Dict[str, Any]] = {}
    for key, meta in raw_entries.items():
        if not isinstance(meta, dict):
            continue
        seen_at_ts = int(meta.get("seenAtTs") or 0)
        entry_ttl = int(meta.get("ttlSec") or CALLBACK_DEDUP_DEFAULT_TTL_SEC)
        if seen_at_ts <= 0:
            continue
        if seen_at_ts + entry_ttl < now:
            continue
        entries[key] = meta
    state["entries"] = entries

    if dedup_key in entries:
        return True

    entries[dedup_key] = {
        "seenAtTs": now,
        "ttlSec": ttl,
        "messageId": str(context.get("messageId") or ""),
        "actionTs": str(context.get("actionTs") or ""),
        "senderKey": str(context.get("senderKey") or ""),
        "command": str(context.get("command") or ""),
        "dedupMode": str(context.get("dedupMode") or ""),
        "eventEnvelopeKey": str(context.get("eventEnvelopeKey") or ""),
    }

    while len(entries) > CALLBACK_DEDUP_MAX_ENTRIES:
        oldest: Optional[Tuple[str, int]] = None
        for key, meta in entries.items():
            ts = 0
            if isinstance(meta, dict):
                try:
                    ts = int(meta.get("seenAtTs") or 0)
                except Exception:
                    ts = 0
            if oldest is None or ts < oldest[1]:
                oldest = (key, ts)
        if oldest is None:
            break
        entries.pop(oldest[0], None)

    save_callback_dedup_state(root, state)
    return False


def resolve_actor(conv: Dict[str, Any], sender: Dict[str, Any]) -> str:
    for key in ("sender", "sender_id"):
        v = conv.get(key)
        if isinstance(v, str) and v.strip():
            return v.strip()
    for key in ("name", "label"):
        v = sender.get(key)
        if isinstance(v, str) and v.strip():
            return v.strip()
    return "unknown"


def load_openid_role_map(root: str) -> Dict[str, str]:
    """Return {open_id -> role} mapping from feishu-bot-openids.json if present.

    In group chat wiring, actor is often an open_id (ou_...). Normalizing it early
    makes bot-loop guards reliable.
    """
    out: Dict[str, str] = {}
    for rel in BOT_OPENID_CONFIG_CANDIDATES:
        path = os.path.join(root, rel)
        if not os.path.exists(path):
            continue
        try:
            with open(path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception:
            continue

        if not isinstance(raw, dict):
            continue

        entries: Dict[str, Any] = {}
        role_map = raw.get("byRole")
        acct_map = raw.get("byAccountId")
        if isinstance(role_map, dict):
            entries.update(role_map)
        if isinstance(acct_map, dict):
            for k, v in acct_map.items():
                entries.setdefault(k, v)
        if not entries:
            entries = raw

        for role, info in entries.items():
            if not isinstance(role, str) or not isinstance(info, dict):
                continue
            open_id = str(info.get("open_id") or info.get("openId") or "").strip()
            if open_id:
                out[open_id] = role

        if out:
            return out

    return out


def normalize_actor(actor: str, openid_role: Dict[str, str]) -> str:
    s = (actor or "").strip()
    if not s:
        return "unknown"
    return openid_role.get(s, s)


def is_bot_sender(actor: str, sender: Dict[str, Any]) -> bool:
    actor_norm = (actor or "").strip().lower()
    if actor_norm in {r.lower() for r in BOT_ROLES}:
        return True
    for key in ("is_bot", "isBot"):
        if bool(sender.get(key)):
            return True
    sender_type = str(sender.get("sender_type") or sender.get("type") or "").strip().lower()
    if "bot" in sender_type:
        return True
    return False


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--root", required=True)
    parser.add_argument("--account-id", default=DEFAULT_ACCOUNT_ID)
    parser.add_argument("--group-id", default="")
    parser.add_argument("--milestones", choices=["send", "dry-run", "off"], default="send")
    parser.add_argument("--actor", default="")
    parser.add_argument("--text", default="")
    args = parser.parse_args()

    raw = args.text if args.text else sys.stdin.read()
    if not raw.strip():
        print(json.dumps({"ok": False, "error": "empty inbound payload"}, ensure_ascii=True))
        return 1

    conv = extract_json_block(raw, "Conversation info (untrusted metadata):")
    sender = extract_json_block(raw, "Sender (untrusted metadata):")

    group_id = args.group_id or str(conv.get("conversation_label") or "").strip() or DEFAULT_GROUP_ID

    openid_role = load_openid_role_map(args.root)
    actor_raw = args.actor.strip() or resolve_actor(conv, sender)
    actor = normalize_actor(actor_raw, openid_role)
    callback = build_callback_context(raw, conv, sender, actor_raw)

    source = "text"
    text = normalize_message_text(raw)
    ack: Dict[str, Any] = {}
    if callback:
        source = "card_callback"
        text = str(callback.get("command") or "").strip() or text
        ack = {
            "ok": True,
            "source": source,
            "messageId": str(callback.get("messageId") or ""),
            "actionTs": str(callback.get("actionTs") or ""),
            "senderKey": str(callback.get("senderKey") or ""),
            "dedupMode": str(callback.get("dedupMode") or ""),
            "dedupTtlSec": int(callback.get("dedupTtlSec") or 0),
            "dedupKey": str(callback.get("dedupKey") or ""),
        }

    was_mentioned = bool(conv.get("was_mentioned"))
    if was_mentioned and "@orchestrator" not in text.lower():
        text = f"@orchestrator {text}".strip()

    if source == "card_callback":
        dedup_key = str(callback.get("dedupKey") or "")
        dedup_ttl_sec = int(callback.get("dedupTtlSec") or CALLBACK_DEDUP_DEFAULT_TTL_SEC)
        is_duplicate = remember_callback_once(args.root, dedup_key, callback, dedup_ttl_sec)
        if is_duplicate:
            ack["deduplicated"] = True
            out = {
                "ok": True,
                "handled": True,
                "deduplicated": True,
                "source": source,
                "actor": actor,
                "groupId": group_id,
                "text": text,
                "routerExitCode": 0,
                "router": {
                    "ok": True,
                    "handled": True,
                    "intent": "deduplicated_callback",
                    "source": source,
                    "ack": ack,
                },
                "routerStdout": "",
                "routerStderr": "",
            }
            print(json.dumps(out, ensure_ascii=True))
            return 0

    if is_bot_sender(actor, sender):
        stripped = text.strip()
        if actor.lower() == args.account_id.lower() or stripped.startswith(MILESTONE_PREFIXES):
            out = {
                "ok": True,
                "handled": True,
                "actor": actor,
                "groupId": group_id,
                "text": text,
                "source": source,
                "routerExitCode": 0,
                "router": {"ok": True, "handled": True, "intent": "ignored_loop"},
                "routerStdout": "",
                "routerStderr": "",
            }
            print(json.dumps(out, ensure_ascii=True))
            return 0

    script_dir = os.path.dirname(os.path.abspath(__file__))
    router = os.path.join(script_dir, "orchestrator-router")
    cmd = [
        router,
        "--root",
        args.root,
        "--actor",
        actor,
        "--text",
        text,
        "--group-id",
        group_id,
        "--account-id",
        args.account_id,
        "--milestones",
        args.milestones,
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True, check=False)

    router_stdout = (proc.stdout or "").strip()
    router_obj = {}
    if router_stdout:
        try:
            parsed = json.loads(router_stdout)
            if isinstance(parsed, dict):
                router_obj = parsed
        except Exception:
            router_obj = {}

    if source == "card_callback":
        if not isinstance(router_obj, dict):
            router_obj = {}
        router_obj["source"] = source
        router_obj["ack"] = ack

    ok = proc.returncode == 0
    if isinstance(router_obj.get("ok"), bool):
        ok = ok and bool(router_obj.get("ok"))

    out = {
        "ok": ok,
        "source": source,
        "deduplicated": False,
        "actor": actor,
        "groupId": group_id,
        "text": text,
        "routerExitCode": proc.returncode,
        "router": router_obj,
        "routerStdout": router_stdout,
        "routerStderr": (proc.stderr or "").strip(),
    }
    print(json.dumps(out, ensure_ascii=True))
    return 0 if ok else 1


if __name__ == "__main__":
    raise SystemExit(main())
