#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import sys
from typing import Any, Dict

DEFAULT_GROUP_ID = "oc_041146c92a9ccb403a7f4f48fb59701d"
DEFAULT_ACCOUNT_ID = "orchestrator"

BOT_ROLES = {"orchestrator", "coder", "debugger", "invest-analyst", "broadcaster"}
MILESTONE_PREFIXES = ("[TASK]", "[CLAIM]", "[DONE]", "[BLOCKED]", "[DIAG]", "[REVIEW]")
BOT_OPENID_CONFIG_CANDIDATES = (
    os.path.join("config", "feishu-bot-openids.json"),
    os.path.join("state", "feishu-bot-openids.json"),
)


def extract_json_block(raw: str, header: str) -> Dict[str, Any]:
    m = re.search(re.escape(header) + r"\s*```json\s*(\{.*?\})\s*```", raw, flags=re.DOTALL)
    if not m:
        return {}
    try:
        obj = json.loads(m.group(1))
        return obj if isinstance(obj, dict) else {}
    except Exception:
        return {}


def normalize_message_text(raw: str) -> str:
    # Extract the message body from an OpenClaw Feishu wrapper text.
    # Keep multi-line messages intact by cutting off before metadata blocks.
    delim = raw.find("Conversation info (untrusted metadata):")
    head = raw if delim < 0 else raw[:delim]

    m = re.search(r"message in group\s+[^:]+:\s*", head, flags=re.IGNORECASE)
    if m:
        return head[m.end() :].strip()

    lines = [ln.strip() for ln in raw.splitlines() if ln.strip()]
    if lines:
        return lines[-1]
    return ""


def resolve_actor(conv: Dict[str, Any], sender: Dict[str, Any]) -> str:
    for key in ("sender", "sender_id"):
        v = conv.get(key)
        if isinstance(v, str) and v.strip():
            return v.strip()
    for key in ("name", "label"):
        v = sender.get(key)
        if isinstance(v, str) and v.strip():
            return v.strip()
    return "unknown"


def load_openid_role_map(root: str) -> Dict[str, str]:
    """Return {open_id -> role} mapping from feishu-bot-openids.json if present.

    In group chat wiring, actor is often an open_id (ou_...). Normalizing it early
    makes bot-loop guards reliable.
    """
    out: Dict[str, str] = {}
    for rel in BOT_OPENID_CONFIG_CANDIDATES:
        path = os.path.join(root, rel)
        if not os.path.exists(path):
            continue
        try:
            with open(path, "r", encoding="utf-8") as f:
                raw = json.load(f)
        except Exception:
            continue

        if not isinstance(raw, dict):
            continue

        entries: Dict[str, Any] = {}
        role_map = raw.get("byRole")
        acct_map = raw.get("byAccountId")
        if isinstance(role_map, dict):
            entries.update(role_map)
        if isinstance(acct_map, dict):
            for k, v in acct_map.items():
                entries.setdefault(k, v)
        if not entries:
            entries = raw

        for role, info in entries.items():
            if not isinstance(role, str) or not isinstance(info, dict):
                continue
            open_id = str(info.get("open_id") or info.get("openId") or "").strip()
            if open_id:
                out[open_id] = role

        if out:
            return out

    return out


def normalize_actor(actor: str, openid_role: Dict[str, str]) -> str:
    s = (actor or "").strip()
    if not s:
        return "unknown"
    return openid_role.get(s, s)


def is_bot_sender(actor: str, sender: Dict[str, Any]) -> bool:
    actor_norm = (actor or "").strip().lower()
    if actor_norm in {r.lower() for r in BOT_ROLES}:
        return True
    for key in ("is_bot", "isBot"):
        if bool(sender.get(key)):
            return True
    sender_type = str(sender.get("sender_type") or sender.get("type") or "").strip().lower()
    if "bot" in sender_type:
        return True
    return False


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--root", required=True)
    parser.add_argument("--account-id", default=DEFAULT_ACCOUNT_ID)
    parser.add_argument("--group-id", default="")
    parser.add_argument("--milestones", choices=["send", "dry-run", "off"], default="send")
    parser.add_argument("--actor", default="")
    parser.add_argument("--text", default="")
    args = parser.parse_args()

    raw = args.text if args.text else sys.stdin.read()
    if not raw.strip():
        print(json.dumps({"ok": False, "error": "empty inbound payload"}, ensure_ascii=True))
        return 1

    conv = extract_json_block(raw, "Conversation info (untrusted metadata):")
    sender = extract_json_block(raw, "Sender (untrusted metadata):")

    group_id = args.group_id or str(conv.get("conversation_label") or "").strip() or DEFAULT_GROUP_ID

    openid_role = load_openid_role_map(args.root)
    actor_raw = args.actor.strip() or resolve_actor(conv, sender)
    actor = normalize_actor(actor_raw, openid_role)
    text = normalize_message_text(raw)

    was_mentioned = bool(conv.get("was_mentioned"))
    if was_mentioned and "@orchestrator" not in text.lower():
        text = f"@orchestrator {text}".strip()

    if is_bot_sender(actor, sender):
        stripped = text.strip()
        if actor.lower() == args.account_id.lower() or stripped.startswith(MILESTONE_PREFIXES):
            out = {
                "ok": True,
                "handled": True,
                "actor": actor,
                "groupId": group_id,
                "text": text,
                "routerExitCode": 0,
                "router": {"ok": True, "handled": True, "intent": "ignored_loop"},
                "routerStdout": "",
                "routerStderr": "",
            }
            print(json.dumps(out, ensure_ascii=True))
            return 0

    script_dir = os.path.dirname(os.path.abspath(__file__))
    router = os.path.join(script_dir, "orchestrator-router")
    cmd = [
        router,
        "--root",
        args.root,
        "--actor",
        actor,
        "--text",
        text,
        "--group-id",
        group_id,
        "--account-id",
        args.account_id,
        "--milestones",
        args.milestones,
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True, check=False)

    router_stdout = (proc.stdout or "").strip()
    router_obj = {}
    if router_stdout:
        try:
            parsed = json.loads(router_stdout)
            if isinstance(parsed, dict):
                router_obj = parsed
        except Exception:
            router_obj = {}

    ok = proc.returncode == 0
    if isinstance(router_obj.get("ok"), bool):
        ok = ok and bool(router_obj.get("ok"))

    out = {
        "ok": ok,
        "actor": actor,
        "groupId": group_id,
        "text": text,
        "routerExitCode": proc.returncode,
        "router": router_obj,
        "routerStdout": router_stdout,
        "routerStderr": (proc.stderr or "").strip(),
    }
    print(json.dumps(out, ensure_ascii=True))
    return 0 if ok else 1


if __name__ == "__main__":
    raise SystemExit(main())
